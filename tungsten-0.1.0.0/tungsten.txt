-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bring fusion to everyone
--   
--   Please see the README on GitHub at
--   <a>https://github.com/nobrakal/tungsten#readme</a>
@package tungsten
@version 0.1.0.0


-- | This module provides the <a>Fix</a> operator which can be used to
--   define fixed-point structures (see examples in
--   <a>Tungsten.Structure.List</a>, <a>Tungsten.Structure.Tree</a> ord
--   <a>Tungsten.Structure.Graph</a>).
--   
--   Defining a type in term of <a>Fix</a> gives access to <a>cata</a> and
--   <a>buildR</a> and the "cata/buildR" rewrite rule (see comment for
--   <a>buildR</a> for how to use it).
--   
--   To use efficiently this module, compile with rewrite rules enabled and
--   the <tt>-fspec-constr</tt> flag.
--   
--   A part of this module was inspired by the <a>Data.Functor.Foldable</a>
--   module from the <a>recursion-schemes package</a>.
module Tungsten.Fix

-- | Operator to define fixed-point types.
newtype Fix f
Fix :: f (Fix f) -> Fix f

-- | A synonym for <a>Fix</a>.
fix :: f (Fix f) -> Fix f

-- | Remove one level of fixed-point.
unfix :: Fix f -> f (Fix f)

-- | Catamorphism. Functions defined in terms of <a>cata</a> (or "good
--   consumers") are subject to fusion with functions exprimed in terms of
--   <a>buildR</a> (or "good producers").
cata :: Functor f => (f a -> a) -> Fix f -> a

-- | Paramorphism. Functions defined in terms of <a>para</a> are <i>not</i>
--   subject to fusion.
para :: Functor f => (f (Fix f, a) -> a) -> Fix f -> a

-- | Anamorphism. Defined in terms of <a>buildR</a>, so subject to fusion
--   with <a>cata</a>.
ana :: Functor f => (a -> f a) -> a -> Fix f

-- | Apomorphism. Functions defined in terms of <a>apo</a> are <i>not</i>
--   subject to fusion.
apo :: Functor f => (a -> f (Either (Fix f) a)) -> a -> Fix f

-- | Hylomorphism.
--   
--   <pre>
--   hylo f g == <a>cata</a> f . <a>ana</a> g
--   </pre>
hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b

-- | Type of arguments of <a>buildR</a>.
type Cata f = forall a. (f a -> a) -> a

-- | <a>buildR</a> abstracts the build of a structure with respect to the
--   fixed-point combinator, such that we have the following rewrite rule
--   (named "cata/buildR"):
--   
--   <pre>
--   cata f (buildR g) = g f
--   </pre>
--   
--   When firing, this remove the build of an intermediate structure. A
--   function expressed with <a>buildR</a> is called a <i>good
--   producer</i>.
--   
--   Note 1. Without rewriting, <a>buildR</a> is just:
--   
--   <pre>
--   buildR g = g Fix
--   </pre>
--   
--   Note 2. The validity of the "cata/buildR" rule is guaranteed by
--   <a>free theorems of Wadler</a>. They are known to fail in presence of
--   <a>seq</a> and <a>undefined</a>, be careful.
--   
--   Note 3. If <tt>g = cata</tt> and a rewriting did not happen, then the
--   "cata/id" rule will replace the <tt>cata Fix</tt> obtained with the
--   inlining of <a>buildR</a> by <a>id</a>.
buildR :: Cata f -> Fix f
instance Data.Functor.Classes.Eq1 f => GHC.Classes.Eq (Tungsten.Fix.Fix f)
instance Data.Functor.Classes.Ord1 f => GHC.Classes.Ord (Tungsten.Fix.Fix f)
instance (GHC.Base.Functor f, Data.Functor.Classes.Show1 f) => GHC.Show.Show (Tungsten.Fix.Fix f)
instance Data.Functor.Classes.Read1 f => GHC.Read.Read (Tungsten.Fix.Fix f)


-- | This module defines a type isomorphic to algebraic graphs (from A.
--   Mokhov, see the <a>algebraic-graphs package</a>), in terms of
--   <a>Fix</a> from <a>Tungsten.Fix</a>.
--   
--   A good consumer is a function that can be fused with a good producer.
--   A good producer is a function that can be fused with a good consumer.
module Tungsten.Structure.Graph

-- | The "factored-out" recursive type for algebraic graphs.
data GraphF a b
EmptyF :: GraphF a b
VertexF :: a -> GraphF a b
OverlayF :: b -> b -> GraphF a b
ConnectF :: b -> b -> GraphF a b
type Graph a = Fix (GraphF a)

-- | The empty graph.
empty :: Graph a

-- | A vertex.
vertex :: a -> Graph a

-- | Overlay two graphs.
overlay :: Graph a -> Graph a -> Graph a

-- | Connect two graphs.
connect :: Graph a -> Graph a -> Graph a

-- | Fold a graph. Good consumer.
foldg :: b -> (a -> b) -> (b -> b -> b) -> (b -> b -> b) -> Graph a -> b

-- | <a>fmap</a> for algebraic graphs. Good consumer and good producer.
mapg :: (a -> b) -> Graph a -> Graph b

-- | <tt>bind</tt> for algebraic graphs. Good consumer and good producer.
bind :: Graph a -> (a -> Graph b) -> Graph b

-- | Test if a vertex is in a graph. Good consumer.
hasVertex :: Eq a => a -> Graph a -> Bool

-- | Construct a graph from a list of edges Good consumer of lists and
--   producer of graphs.
edges :: [(a, a)] -> Graph a
instance GHC.Base.Functor (Tungsten.Structure.Graph.GraphF a)
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Tungsten.Structure.Graph.GraphF a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Tungsten.Structure.Graph.GraphF a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Tungsten.Structure.Graph.GraphF a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Tungsten.Structure.Graph.GraphF a b)
instance Data.Functor.Classes.Show2 Tungsten.Structure.Graph.GraphF
instance GHC.Show.Show a => Data.Functor.Classes.Show1 (Tungsten.Structure.Graph.GraphF a)


-- | This module defines a type isomorphic to linked lists, in terms of
--   <a>Fix</a> from <a>Tungsten.Fix</a>.
--   
--   A good consumer is a function that can be fused with a good producer.
--   A good producer is a function that can be fused with a good consumer.
module Tungsten.Structure.List

-- | The factored-out recursive type for lists.
data ListF a b
NilF :: ListF a b
ConsF :: a -> b -> ListF a b

-- | Linked lists as a fixed-point.
type List a = Fix (ListF a)

-- | The empty list. Similar to 'Prelude.[]' for Prelude lists.
nil :: List a

-- | The cons operator. Similar to 'Prelude.(:)' for Prelude lists.
cons :: a -> List a -> List a

-- | The classical right fold. Good consumer.
foldr :: (a -> b -> b) -> b -> List a -> b

-- | The classical map. Good consumer and good producer.
map :: (a -> b) -> List a -> List b

-- | Search an element in a list. Good consumer.
elem :: Eq a => a -> List a -> Bool

-- | <tt>range start end</tt> will produce a list containing int in
--   ascending order from <tt>start</tt> (inclusive) to <tt>end</tt>
--   (exclusive). Good producer.
range :: Int -> Int -> List Int

-- | Transform a Prelude list into a fixed-point one. Good producer
--   (fixed-point lists) and good consumer of (of Prelude lists).
toList :: [a] -> List a

-- | Transform a fixed-point list into a Prelude one. Good producer (of
--   Prelude lists) and good consumer (of fixed-point lists).
fromList :: List a -> [a]
instance GHC.Base.Functor (Tungsten.Structure.List.ListF a)
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Tungsten.Structure.List.ListF a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Tungsten.Structure.List.ListF a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Tungsten.Structure.List.ListF a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Tungsten.Structure.List.ListF a b)
instance Data.Functor.Classes.Eq2 Tungsten.Structure.List.ListF
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Tungsten.Structure.List.ListF a)
instance Data.Functor.Classes.Ord2 Tungsten.Structure.List.ListF
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Tungsten.Structure.List.ListF a)
instance Data.Functor.Classes.Show2 Tungsten.Structure.List.ListF
instance GHC.Show.Show a => Data.Functor.Classes.Show1 (Tungsten.Structure.List.ListF a)


-- | This module defines a type isomorphic to binary trees, in terms of
--   <a>Fix</a> from <a>Tungsten.Fix</a>.
--   
--   A good consumer is a function that can be fused with a good producer.
--   A good producer is a function that can be fused with a good consumer.
module Tungsten.Structure.Tree

-- | The "factored-out" recursive type for binary trees.
data TreeF a b
EmptyF :: TreeF a b
LeafF :: a -> TreeF a b
NodeF :: b -> b -> TreeF a b

-- | Binary trees expressed as a fixed-point.
type Tree a = Fix (TreeF a)

-- | The empty tree.
empty :: Tree a

-- | A leaf.
leaf :: a -> Tree a

-- | A node.
node :: Tree a -> Tree a -> Tree a

-- | <a>fmap</a> for trees. Good consumer and good producer.
mapt :: (a -> b) -> Tree a -> Tree b

-- | <tt>bind</tt> for trees. Good consumer and good producer.
bind :: Tree a -> (a -> Tree b) -> Tree b

-- | <tt>hasLeaf s t</tt> tests if the leaf <tt>s</tt> is present in the
--   tree <tt>t</tt>. Good consumer.
hasLeaf :: Eq a => a -> Tree a -> Bool

-- | Construct a binary tree from a list. Good consumer (of Prelude lists)
--   and good producer (of trees).
treeFromList :: [Tree a] -> Tree a

-- | <tt>leftTree n</tt> construct a tree with n leaves from 1 to n. Good
--   producer.
leftTreeN :: Int -> Tree Int
instance GHC.Base.Functor (Tungsten.Structure.Tree.TreeF a)
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Tungsten.Structure.Tree.TreeF a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Tungsten.Structure.Tree.TreeF a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Tungsten.Structure.Tree.TreeF a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Tungsten.Structure.Tree.TreeF a b)
instance Data.Functor.Classes.Eq2 Tungsten.Structure.Tree.TreeF
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Tungsten.Structure.Tree.TreeF a)
instance Data.Functor.Classes.Show2 Tungsten.Structure.Tree.TreeF
instance GHC.Show.Show a => Data.Functor.Classes.Show1 (Tungsten.Structure.Tree.TreeF a)
